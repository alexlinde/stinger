"""Settings API endpoints."""
from pathlib import Path
from typing import Optional

from fastapi import APIRouter, HTTPException
from pydantic import BaseModel, Field

router = APIRouter(prefix="/settings", tags=["settings"])

# Path to .env file in the backend directory
ENV_FILE = Path(__file__).parent.parent.parent / ".env"


class SettingsModel(BaseModel):
    """Settings model for API responses."""
    
    # Server settings
    host: str = Field(default="0.0.0.0", description="Server host")
    port: int = Field(default=8000, description="Server port")
    debug: bool = Field(default=False, description="Debug mode")
    
    # Paths
    data_dir: str = Field(default="data", description="Data directory path")
    people_dir: str = Field(default="data/people", description="People directory path")
    
    # Face recognition
    detection_score_threshold: float = Field(default=0.5, description="Face detection confidence threshold (0.0-1.0)")
    embedding_distance_threshold: float = Field(default=0.6, description="Face matching distance threshold (lower = stricter)")
    upscale_factor: float = Field(default=1.5, description="Image upscale factor for better detection")
    
    # Audio
    audio_cooldown_seconds: float = Field(default=30.0, description="Cooldown between theme plays for same person (seconds)")
    
    # Model
    insightface_model: str = Field(default="buffalo_l", description="InsightFace model name")
    
    # Camera
    camera_device: int = Field(default=0, description="Camera device index")
    camera_width: int = Field(default=1280, description="Camera capture width")
    camera_height: int = Field(default=720, description="Camera capture height")
    camera_fps: int = Field(default=15, description="Camera frames per second")
    
    # Kiosk
    kiosk_enabled: bool = Field(default=True, description="Enable kiosk mode")
    recognition_interval_ms: int = Field(default=200, description="Recognition interval in milliseconds")
    
    # Performance
    low_power_mode: bool = Field(default=False, description="Enable low power mode for slower hardware")
    skip_upscale_retry: bool = Field(default=False, description="Skip upscaling retry when no face detected")
    min_recognition_interval_ms: int = Field(default=100, description="Minimum recognition interval (ms)")
    max_recognition_interval_ms: int = Field(default=1000, description="Maximum recognition interval (ms)")
    target_process_time_ms: int = Field(default=150, description="Target processing time (ms)")


class SettingsUpdate(BaseModel):
    """Partial settings update model."""
    
    # Server settings
    host: Optional[str] = None
    port: Optional[int] = None
    debug: Optional[bool] = None
    
    # Paths
    data_dir: Optional[str] = None
    people_dir: Optional[str] = None
    
    # Face recognition
    detection_score_threshold: Optional[float] = None
    embedding_distance_threshold: Optional[float] = None
    upscale_factor: Optional[float] = None
    
    # Audio
    audio_cooldown_seconds: Optional[float] = None
    
    # Model
    insightface_model: Optional[str] = None
    
    # Camera
    camera_device: Optional[int] = None
    camera_width: Optional[int] = None
    camera_height: Optional[int] = None
    camera_fps: Optional[int] = None
    
    # Kiosk
    kiosk_enabled: Optional[bool] = None
    recognition_interval_ms: Optional[int] = None
    
    # Performance
    low_power_mode: Optional[bool] = None
    skip_upscale_retry: Optional[bool] = None
    min_recognition_interval_ms: Optional[int] = None
    max_recognition_interval_ms: Optional[int] = None
    target_process_time_ms: Optional[int] = None


def read_env_file() -> dict[str, str]:
    """Read the .env file and return as dictionary."""
    env_vars = {}
    if ENV_FILE.exists():
        with open(ENV_FILE, "r") as f:
            for line in f:
                line = line.strip()
                if line and not line.startswith("#") and "=" in line:
                    key, _, value = line.partition("=")
                    # Remove quotes if present
                    value = value.strip()
                    if (value.startswith('"') and value.endswith('"')) or \
                       (value.startswith("'") and value.endswith("'")):
                        value = value[1:-1]
                    env_vars[key.strip().upper()] = value
    return env_vars


def write_env_file(env_vars: dict[str, str]) -> None:
    """Write dictionary to .env file."""
    lines = []
    lines.append("# Stinger Configuration")
    lines.append("# Generated by Settings UI - restart the server for changes to take effect")
    lines.append("")
    
    # Group settings by category
    categories = {
        "Server": ["HOST", "PORT", "DEBUG"],
        "Paths": ["DATA_DIR", "PEOPLE_DIR"],
        "Face Recognition": ["DETECTION_SCORE_THRESHOLD", "EMBEDDING_DISTANCE_THRESHOLD", "UPSCALE_FACTOR"],
        "Audio": ["AUDIO_COOLDOWN_SECONDS"],
        "Model": ["INSIGHTFACE_MODEL"],
        "Camera": ["CAMERA_DEVICE", "CAMERA_WIDTH", "CAMERA_HEIGHT", "CAMERA_FPS"],
        "Kiosk": ["KIOSK_ENABLED", "RECOGNITION_INTERVAL_MS"],
        "Performance": ["LOW_POWER_MODE", "SKIP_UPSCALE_RETRY", "MIN_RECOGNITION_INTERVAL_MS", 
                       "MAX_RECOGNITION_INTERVAL_MS", "TARGET_PROCESS_TIME_MS"],
    }
    
    for category, keys in categories.items():
        category_vars = {k: v for k, v in env_vars.items() if k in keys}
        if category_vars:
            lines.append(f"# {category}")
            for key in keys:
                if key in env_vars:
                    lines.append(f"{key}={env_vars[key]}")
            lines.append("")
    
    # Add any remaining vars not in categories
    handled_keys = set()
    for keys in categories.values():
        handled_keys.update(keys)
    
    remaining = {k: v for k, v in env_vars.items() if k not in handled_keys}
    if remaining:
        lines.append("# Other")
        for key, value in remaining.items():
            lines.append(f"{key}={value}")
        lines.append("")
    
    with open(ENV_FILE, "w") as f:
        f.write("\n".join(lines))


def get_current_settings() -> SettingsModel:
    """Get current settings from .env file and defaults."""
    from ..core.config import settings as app_settings
    
    # Start with current runtime settings
    return SettingsModel(
        host=app_settings.host,
        port=app_settings.port,
        debug=app_settings.debug,
        data_dir=str(app_settings.data_dir),
        people_dir=str(app_settings.people_dir),
        detection_score_threshold=app_settings.detection_score_threshold,
        embedding_distance_threshold=app_settings.embedding_distance_threshold,
        upscale_factor=app_settings.upscale_factor,
        audio_cooldown_seconds=app_settings.audio_cooldown_seconds,
        insightface_model=app_settings.insightface_model,
        camera_device=app_settings.camera_device,
        camera_width=app_settings.camera_width,
        camera_height=app_settings.camera_height,
        camera_fps=app_settings.camera_fps,
        kiosk_enabled=app_settings.kiosk_enabled,
        recognition_interval_ms=app_settings.recognition_interval_ms,
        low_power_mode=app_settings.low_power_mode,
        skip_upscale_retry=app_settings.skip_upscale_retry,
        min_recognition_interval_ms=app_settings.min_recognition_interval_ms,
        max_recognition_interval_ms=app_settings.max_recognition_interval_ms,
        target_process_time_ms=app_settings.target_process_time_ms,
    )


@router.get("", response_model=SettingsModel)
async def get_settings():
    """Get current settings."""
    return get_current_settings()


@router.put("", response_model=SettingsModel)
async def update_settings(update: SettingsUpdate):
    """
    Update settings.
    
    Note: Changes are saved to .env file but require a server restart to take effect.
    """
    # Read current .env values
    env_vars = read_env_file()
    
    # Get current settings as base
    current = get_current_settings()
    
    # Apply updates
    update_dict = update.model_dump(exclude_none=True)
    
    for key, value in update_dict.items():
        env_key = key.upper()
        # Convert booleans to lowercase strings
        if isinstance(value, bool):
            env_vars[env_key] = str(value).lower()
        else:
            env_vars[env_key] = str(value)
    
    # Write back to .env file
    try:
        write_env_file(env_vars)
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"Failed to save settings: {e}")
    
    # Return the new settings (what's in the file, not runtime)
    # Merge current with updates for the response
    current_dict = current.model_dump()
    current_dict.update(update_dict)
    return SettingsModel(**current_dict)


@router.post("/restart-required")
async def check_restart_required():
    """Check if a restart is required for settings to take effect."""
    # Compare runtime settings with .env file
    env_vars = read_env_file()
    current = get_current_settings()
    current_dict = current.model_dump()
    
    differences = []
    for key, runtime_value in current_dict.items():
        env_key = key.upper()
        if env_key in env_vars:
            env_value = env_vars[env_key]
            # Compare as strings
            runtime_str = str(runtime_value).lower() if isinstance(runtime_value, bool) else str(runtime_value)
            if runtime_str != env_value:
                differences.append({
                    "setting": key,
                    "current": runtime_value,
                    "pending": env_value
                })
    
    return {
        "restart_required": len(differences) > 0,
        "pending_changes": differences
    }

